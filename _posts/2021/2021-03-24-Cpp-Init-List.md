---
title: C++ 构造函数初始化列表和聚合类初始化
date: "2021-03-24 19:56:00"
tags: [C++,docs]
category: blog
---
在 C++ 类的封装 一文中说到，类的实例化依赖于构造函数。但是，有一个隐藏的问题在其中：类的成员能否使用 const 修饰？因为 const 修饰的变量不能修改。同理，引用类型也不能被二次修改。为了解决这个问题，C++ 引入了初始化列表。

<!-- more -->

初始化列表的语法如下：

```class-name parameter-list(optional)except-spec(optional)attr(optional){}```

```cpp

class A {
    const int a;
    int b;
    A(int i):a(10),b(i){
    }
};

```

并且，如果派生类想要调用基类的构造函数，那么只能在初始化列表中调用。

```cpp

class B :public A {
    A:B(){
    }
};

```

派生类中包括默认在内的构造函数也可以通过上述方法调用其他重载的构造函数进行初始化。

初始化的动作发生在执行函数体之前，并且初始化顺序根据成员在类中的顺序而不是初始化列表中的顺序，一般初始化列表的顺序和类中顺序一致。

和普通函数一样，构造函数也支持默认实参，不过需要注意一件事：***带默认实参的构造函数不能在类外使用作用域运算符定义***。

对于 C++ 来说，struct 和 class 都可以声明一个类，但是在 C 中没有类的概念，只有 struct 结构体。当一个类所有成员都是 public，没有使用类内初始化，没有构造函数，没有基类也没有使用虚函数，此时可以使用初始化列表的形式初始化成员。

```cpp

struct Data {
    int ival;
    string s;
};

Data a = {0,"string"};

```

初始化列表中顺序需要和类的成员声明顺序一致。